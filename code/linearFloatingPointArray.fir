;buildInfoPackage: chisel3, version: 3.2.4, scalaVersion: 2.12.10, sbtVersion: 1.3.2
circuit linearFloatingPointArray : 
  module linearMultiplier : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_1 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_1 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_2 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_2 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_3 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_3 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_4 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_4 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_5 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_5 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_6 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_6 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_7 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_7 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_8 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_8 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_8 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_9 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_9 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_9 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_10 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_10 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_10 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_11 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_11 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_11 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_12 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_12 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_12 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_13 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_13 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_13 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_14 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_14 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_14 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module linearMultiplier_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    node exponentSum = add(io.A.exponent, io.B.exponent) @[Multiplier.scala 15:41]
    node fractionProduct = mul(io.A.fraction, io.B.fraction) @[Multiplier.scala 16:45]
    node _T = add(asSInt(UInt<7>("h030")), exponentSum) @[Multiplier.scala 17:34]
    node shift = sub(_T, asSInt(UInt<6>("h014"))) @[Multiplier.scala 17:49]
    node _T_1 = lt(shift, asSInt(UInt<1>("h00"))) @[Multiplier.scala 18:32]
    node _T_2 = sub(asSInt(UInt<1>("h00")), shift) @[Multiplier.scala 18:59]
    node _T_3 = tail(_T_2, 1) @[Multiplier.scala 18:59]
    node _T_4 = asSInt(_T_3) @[Multiplier.scala 18:59]
    node _T_5 = asUInt(_T_4) @[Multiplier.scala 18:67]
    node _T_6 = dshr(fractionProduct, _T_5) @[Multiplier.scala 18:55]
    node _T_7 = asUInt(shift) @[Multiplier.scala 18:100]
    node _T_8 = dshl(fractionProduct, _T_7) @[Multiplier.scala 18:91]
    node number = mux(_T_1, _T_6, _T_8) @[Multiplier.scala 18:25]
    node _T_9 = or(io.A.zero, io.B.zero) @[Multiplier.scala 20:34]
    node _T_10 = sub(asSInt(UInt<1>("h00")), asSInt(UInt<6>("h014"))) @[Multiplier.scala 20:57]
    node _T_11 = tail(_T_10, 1) @[Multiplier.scala 20:57]
    node _T_12 = asSInt(_T_11) @[Multiplier.scala 20:57]
    node _T_13 = lt(shift, _T_12) @[Multiplier.scala 20:55]
    node _T_14 = or(_T_9, _T_13) @[Multiplier.scala 20:46]
    io.out.zero <= _T_14 @[Multiplier.scala 20:21]
    node _T_15 = or(io.A.nan, io.B.nan) @[Multiplier.scala 21:32]
    node _T_16 = geq(shift, asSInt(UInt<7>("h03b"))) @[Multiplier.scala 21:52]
    node _T_17 = or(_T_15, _T_16) @[Multiplier.scala 21:43]
    io.out.nan <= _T_17 @[Multiplier.scala 21:20]
    node _T_18 = xor(io.A.sign, io.B.sign) @[Multiplier.scala 22:41]
    node _T_19 = bits(_T_18, 0, 0) @[Multiplier.scala 22:54]
    node _T_20 = asSInt(number) @[Multiplier.scala 22:70]
    node _T_21 = sub(asSInt(UInt<1>("h00")), _T_20) @[Multiplier.scala 22:62]
    node _T_22 = tail(_T_21, 1) @[Multiplier.scala 22:62]
    node _T_23 = asSInt(_T_22) @[Multiplier.scala 22:62]
    node _T_24 = asSInt(number) @[Multiplier.scala 22:85]
    node _T_25 = mux(_T_19, _T_23, _T_24) @[Multiplier.scala 22:29]
    io.out.number <= _T_25 @[Multiplier.scala 22:23]
    
  module linearMultiplierMAC_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}}
    
    inst multiplier of linearMultiplier_15 @[Multiplier.scala 33:32]
    multiplier.clock <= clock
    multiplier.reset <= reset
    multiplier.io.A.fraction <= io.A.fraction @[Multiplier.scala 34:25]
    multiplier.io.A.exponent <= io.A.exponent @[Multiplier.scala 34:25]
    multiplier.io.A.sign <= io.A.sign @[Multiplier.scala 34:25]
    multiplier.io.A.nan <= io.A.nan @[Multiplier.scala 34:25]
    multiplier.io.A.zero <= io.A.zero @[Multiplier.scala 34:25]
    multiplier.io.B.fraction <= io.B.fraction @[Multiplier.scala 35:25]
    multiplier.io.B.exponent <= io.B.exponent @[Multiplier.scala 35:25]
    multiplier.io.B.sign <= io.B.sign @[Multiplier.scala 35:25]
    multiplier.io.B.nan <= io.B.nan @[Multiplier.scala 35:25]
    multiplier.io.B.zero <= io.B.zero @[Multiplier.scala 35:25]
    node _T = add(multiplier.io.out.number, io.C.number) @[Multiplier.scala 36:44]
    node _T_1 = tail(_T, 1) @[Multiplier.scala 36:44]
    node sum = asSInt(_T_1) @[Multiplier.scala 36:44]
    node _T_2 = and(multiplier.io.out.zero, io.C.zero) @[Multiplier.scala 37:48]
    node _T_3 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:76]
    node _T_4 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 37:127]
    node _T_5 = eq(_T_3, _T_4) @[Multiplier.scala 37:99]
    node _T_6 = bits(io.C.number, 80, 80) @[Multiplier.scala 37:166]
    node _T_7 = eq(_T_6, UInt<1>("h01")) @[Multiplier.scala 37:189]
    node _T_8 = and(_T_5, _T_7) @[Multiplier.scala 37:151]
    node _T_9 = bits(sum, 80, 80) @[Multiplier.scala 37:205]
    node _T_10 = eq(_T_9, UInt<1>("h00")) @[Multiplier.scala 37:228]
    node _T_11 = and(_T_8, _T_10) @[Multiplier.scala 37:198]
    node _T_12 = or(_T_2, _T_11) @[Multiplier.scala 37:61]
    io.out.zero <= _T_12 @[Multiplier.scala 37:21]
    node _T_13 = or(multiplier.io.out.nan, io.C.nan) @[Multiplier.scala 38:45]
    node _T_14 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:71]
    node _T_15 = bits(multiplier.io.out.number, 80, 80) @[Multiplier.scala 38:122]
    node _T_16 = eq(_T_14, _T_15) @[Multiplier.scala 38:94]
    node _T_17 = bits(io.C.number, 80, 80) @[Multiplier.scala 38:161]
    node _T_18 = eq(_T_17, UInt<1>("h00")) @[Multiplier.scala 38:184]
    node _T_19 = and(_T_16, _T_18) @[Multiplier.scala 38:146]
    node _T_20 = bits(sum, 80, 80) @[Multiplier.scala 38:200]
    node _T_21 = eq(_T_20, UInt<1>("h01")) @[Multiplier.scala 38:223]
    node _T_22 = and(_T_19, _T_21) @[Multiplier.scala 38:193]
    node _T_23 = or(_T_13, _T_22) @[Multiplier.scala 38:56]
    io.out.nan <= _T_23 @[Multiplier.scala 38:20]
    io.out.number <= sum @[Multiplier.scala 39:23]
    
  module linearTile_15 : 
    input clock : Clock
    input reset : Reset
    output io : {flip A_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip B_in : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, flip prop_in : UInt<1>, A_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, B_out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, prop_out : UInt<1>}
    
    node _T = not(io.prop_in) @[Tile.scala 22:45]
    reg A0 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when _T : @[Reg.scala 16:19]
      A0.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A0.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A0.sign <= io.A_in.sign @[Reg.scala 16:23]
      A0.nan <= io.A_in.nan @[Reg.scala 16:23]
      A0.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    reg A1 : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Reg.scala 15:16]
    when io.prop_in : @[Reg.scala 16:19]
      A1.fraction <= io.A_in.fraction @[Reg.scala 16:23]
      A1.exponent <= io.A_in.exponent @[Reg.scala 16:23]
      A1.sign <= io.A_in.sign @[Reg.scala 16:23]
      A1.nan <= io.A_in.nan @[Reg.scala 16:23]
      A1.zero <= io.A_in.zero @[Reg.scala 16:23]
      skip @[Reg.scala 16:19]
    node _T_1 = mux(io.prop_in, A1, A0) @[Tile.scala 25:36]
    reg A : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 25:32]
    A.fraction <= _T_1.fraction @[Tile.scala 25:32]
    A.exponent <= _T_1.exponent @[Tile.scala 25:32]
    A.sign <= _T_1.sign @[Tile.scala 25:32]
    A.nan <= _T_1.nan @[Tile.scala 25:32]
    A.zero <= _T_1.zero @[Tile.scala 25:32]
    reg B : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}, clock @[Tile.scala 26:32]
    B.fraction <= io.B_in.fraction @[Tile.scala 26:32]
    B.exponent <= io.B_in.exponent @[Tile.scala 26:32]
    B.sign <= io.B_in.sign @[Tile.scala 26:32]
    B.nan <= io.B_in.nan @[Tile.scala 26:32]
    B.zero <= io.B_in.zero @[Tile.scala 26:32]
    reg prop : UInt<1>, clock @[Tile.scala 27:35]
    prop <= io.prop_in @[Tile.scala 27:35]
    inst mac of linearMultiplierMAC_15 @[Tile.scala 29:33]
    mac.clock <= clock
    mac.reset <= reset
    node _T_2 = mux(io.prop_in, A0, A1) @[Tile.scala 30:32]
    mac.io.A.fraction <= _T_2.fraction @[Tile.scala 30:26]
    mac.io.A.exponent <= _T_2.exponent @[Tile.scala 30:26]
    mac.io.A.sign <= _T_2.sign @[Tile.scala 30:26]
    mac.io.A.nan <= _T_2.nan @[Tile.scala 30:26]
    mac.io.A.zero <= _T_2.zero @[Tile.scala 30:26]
    mac.io.B.fraction <= io.B_in.fraction @[Tile.scala 31:26]
    mac.io.B.exponent <= io.B_in.exponent @[Tile.scala 31:26]
    mac.io.B.sign <= io.B_in.sign @[Tile.scala 31:26]
    mac.io.B.nan <= io.B_in.nan @[Tile.scala 31:26]
    mac.io.B.zero <= io.B_in.zero @[Tile.scala 31:26]
    mac.io.C.number <= io.C_in.number @[Tile.scala 32:26]
    mac.io.C.nan <= io.C_in.nan @[Tile.scala 32:26]
    mac.io.C.zero <= io.C_in.zero @[Tile.scala 32:26]
    reg C : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}, clock @[Tile.scala 34:32]
    C.number <= mac.io.out.number @[Tile.scala 34:32]
    C.nan <= mac.io.out.nan @[Tile.scala 34:32]
    C.zero <= mac.io.out.zero @[Tile.scala 34:32]
    io.A_out.fraction <= A.fraction @[Tile.scala 36:26]
    io.A_out.exponent <= A.exponent @[Tile.scala 36:26]
    io.A_out.sign <= A.sign @[Tile.scala 36:26]
    io.A_out.nan <= A.nan @[Tile.scala 36:26]
    io.A_out.zero <= A.zero @[Tile.scala 36:26]
    io.B_out.fraction <= B.fraction @[Tile.scala 37:26]
    io.B_out.exponent <= B.exponent @[Tile.scala 37:26]
    io.B_out.sign <= B.sign @[Tile.scala 37:26]
    io.B_out.nan <= B.nan @[Tile.scala 37:26]
    io.B_out.zero <= B.zero @[Tile.scala 37:26]
    io.C_out.number <= C.number @[Tile.scala 38:26]
    io.C_out.nan <= C.nan @[Tile.scala 38:26]
    io.C_out.zero <= C.zero @[Tile.scala 38:26]
    io.prop_out <= prop @[Tile.scala 39:29]
    
  module toFloatingPointUnpacked : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_1 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_2 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_3 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_4 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_5 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_6 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module toFloatingPointUnpacked_7 : 
    input clock : Clock
    input reset : Reset
    output io : {flip in : UInt<16>, out : {zero : UInt<1>, nan : UInt<1>, sign : UInt<1>, exponent : SInt<6>, fraction : UInt<11>}}
    
    wire subnormal : UInt<4> @[Conversion.scala 45:29]
    node _T = bits(io.in, 14, 10) @[Conversion.scala 47:32]
    node _T_1 = neq(_T, UInt<1>("h00")) @[Conversion.scala 47:77]
    node _T_2 = not(_T_1) @[Conversion.scala 47:26]
    node _T_3 = bits(io.in, 9, 0) @[Conversion.scala 47:111]
    node _T_4 = bits(_T_3, 7, 0) @[Bitwise.scala 108:18]
    node _T_5 = shl(UInt<4>("h0f"), 4) @[Bitwise.scala 101:47]
    node _T_6 = xor(UInt<8>("h0ff"), _T_5) @[Bitwise.scala 101:21]
    node _T_7 = shr(_T_4, 4) @[Bitwise.scala 102:21]
    node _T_8 = and(_T_7, _T_6) @[Bitwise.scala 102:31]
    node _T_9 = bits(_T_4, 3, 0) @[Bitwise.scala 102:46]
    node _T_10 = shl(_T_9, 4) @[Bitwise.scala 102:65]
    node _T_11 = not(_T_6) @[Bitwise.scala 102:77]
    node _T_12 = and(_T_10, _T_11) @[Bitwise.scala 102:75]
    node _T_13 = or(_T_8, _T_12) @[Bitwise.scala 102:39]
    node _T_14 = bits(_T_6, 5, 0) @[Bitwise.scala 101:28]
    node _T_15 = shl(_T_14, 2) @[Bitwise.scala 101:47]
    node _T_16 = xor(_T_6, _T_15) @[Bitwise.scala 101:21]
    node _T_17 = shr(_T_13, 2) @[Bitwise.scala 102:21]
    node _T_18 = and(_T_17, _T_16) @[Bitwise.scala 102:31]
    node _T_19 = bits(_T_13, 5, 0) @[Bitwise.scala 102:46]
    node _T_20 = shl(_T_19, 2) @[Bitwise.scala 102:65]
    node _T_21 = not(_T_16) @[Bitwise.scala 102:77]
    node _T_22 = and(_T_20, _T_21) @[Bitwise.scala 102:75]
    node _T_23 = or(_T_18, _T_22) @[Bitwise.scala 102:39]
    node _T_24 = bits(_T_16, 6, 0) @[Bitwise.scala 101:28]
    node _T_25 = shl(_T_24, 1) @[Bitwise.scala 101:47]
    node _T_26 = xor(_T_16, _T_25) @[Bitwise.scala 101:21]
    node _T_27 = shr(_T_23, 1) @[Bitwise.scala 102:21]
    node _T_28 = and(_T_27, _T_26) @[Bitwise.scala 102:31]
    node _T_29 = bits(_T_23, 6, 0) @[Bitwise.scala 102:46]
    node _T_30 = shl(_T_29, 1) @[Bitwise.scala 102:65]
    node _T_31 = not(_T_26) @[Bitwise.scala 102:77]
    node _T_32 = and(_T_30, _T_31) @[Bitwise.scala 102:75]
    node _T_33 = or(_T_28, _T_32) @[Bitwise.scala 102:39]
    node _T_34 = bits(_T_3, 9, 8) @[Bitwise.scala 108:44]
    node _T_35 = bits(_T_34, 0, 0) @[Bitwise.scala 108:18]
    node _T_36 = bits(_T_34, 1, 1) @[Bitwise.scala 108:44]
    node _T_37 = cat(_T_35, _T_36) @[Cat.scala 29:58]
    node _T_38 = cat(_T_33, _T_37) @[Cat.scala 29:58]
    node _T_39 = bits(_T_38, 0, 0) @[OneHot.scala 47:40]
    node _T_40 = bits(_T_38, 1, 1) @[OneHot.scala 47:40]
    node _T_41 = bits(_T_38, 2, 2) @[OneHot.scala 47:40]
    node _T_42 = bits(_T_38, 3, 3) @[OneHot.scala 47:40]
    node _T_43 = bits(_T_38, 4, 4) @[OneHot.scala 47:40]
    node _T_44 = bits(_T_38, 5, 5) @[OneHot.scala 47:40]
    node _T_45 = bits(_T_38, 6, 6) @[OneHot.scala 47:40]
    node _T_46 = bits(_T_38, 7, 7) @[OneHot.scala 47:40]
    node _T_47 = bits(_T_38, 8, 8) @[OneHot.scala 47:40]
    node _T_48 = bits(_T_38, 9, 9) @[OneHot.scala 47:40]
    node _T_49 = mux(_T_47, UInt<4>("h08"), UInt<4>("h09")) @[Mux.scala 47:69]
    node _T_50 = mux(_T_46, UInt<3>("h07"), _T_49) @[Mux.scala 47:69]
    node _T_51 = mux(_T_45, UInt<3>("h06"), _T_50) @[Mux.scala 47:69]
    node _T_52 = mux(_T_44, UInt<3>("h05"), _T_51) @[Mux.scala 47:69]
    node _T_53 = mux(_T_43, UInt<3>("h04"), _T_52) @[Mux.scala 47:69]
    node _T_54 = mux(_T_42, UInt<2>("h03"), _T_53) @[Mux.scala 47:69]
    node _T_55 = mux(_T_41, UInt<2>("h02"), _T_54) @[Mux.scala 47:69]
    node _T_56 = mux(_T_40, UInt<1>("h01"), _T_55) @[Mux.scala 47:69]
    node _T_57 = mux(_T_39, UInt<1>("h00"), _T_56) @[Mux.scala 47:69]
    node _T_58 = mux(_T_2, _T_57, UInt<1>("h00")) @[Conversion.scala 47:25]
    subnormal <= _T_58 @[Conversion.scala 47:19]
    node _T_59 = bits(io.in, 14, 0) @[Conversion.scala 49:30]
    node _T_60 = neq(_T_59, UInt<1>("h00")) @[Conversion.scala 49:48]
    node _T_61 = not(_T_60) @[Conversion.scala 49:24]
    io.out.zero <= _T_61 @[Conversion.scala 49:21]
    node _T_62 = bits(io.in, 14, 10) @[Conversion.scala 50:28]
    node _T_63 = eq(_T_62, UInt<5>("h01f")) @[Conversion.scala 50:73]
    io.out.nan <= _T_63 @[Conversion.scala 50:20]
    node _T_64 = bits(io.in, 15, 15) @[Conversion.scala 51:29]
    io.out.sign <= _T_64 @[Conversion.scala 51:21]
    node _T_65 = bits(io.in, 14, 10) @[Conversion.scala 52:33]
    node _T_66 = cvt(_T_65) @[Conversion.scala 52:78]
    node _T_67 = sub(_T_66, asSInt(UInt<5>("h0f"))) @[Conversion.scala 52:83]
    node _T_68 = tail(_T_67, 1) @[Conversion.scala 52:83]
    node _T_69 = asSInt(_T_68) @[Conversion.scala 52:83]
    node _T_70 = cvt(subnormal) @[Conversion.scala 52:104]
    node _T_71 = sub(_T_69, _T_70) @[Conversion.scala 52:92]
    node _T_72 = tail(_T_71, 1) @[Conversion.scala 52:92]
    node _T_73 = asSInt(_T_72) @[Conversion.scala 52:92]
    io.out.exponent <= _T_73 @[Conversion.scala 52:25]
    node _T_74 = bits(io.in, 14, 10) @[Conversion.scala 53:38]
    node _T_75 = neq(_T_74, UInt<1>("h00")) @[Conversion.scala 53:83]
    node _T_76 = not(_T_75) @[Conversion.scala 53:32]
    node _T_77 = bits(io.in, 9, 0) @[Conversion.scala 53:97]
    node _T_78 = dshl(_T_77, subnormal) @[Conversion.scala 53:131]
    node _T_79 = cat(_T_78, UInt<1>("h00")) @[Cat.scala 29:58]
    node _T_80 = bits(io.in, 9, 0) @[Conversion.scala 53:165]
    node _T_81 = cat(UInt<1>("h01"), _T_80) @[Cat.scala 29:58]
    node _T_82 = mux(_T_76, _T_79, _T_81) @[Conversion.scala 53:31]
    io.out.fraction <= _T_82 @[Conversion.scala 53:25]
    
  module linearFloatingPointArray : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip A_in : UInt<16>[4], flip B_in : UInt<16>[4], flip C_in : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}[4], flip prop_in : UInt<1>[4], C_out : {zero : UInt<1>, nan : UInt<1>, number : SInt<81>}[4]}
    
    inst array_0_0 of linearTile @[Array.scala 21:78]
    array_0_0.clock <= clock
    array_0_0.reset <= reset
    inst array_0_1 of linearTile_1 @[Array.scala 21:78]
    array_0_1.clock <= clock
    array_0_1.reset <= reset
    inst array_0_2 of linearTile_2 @[Array.scala 21:78]
    array_0_2.clock <= clock
    array_0_2.reset <= reset
    inst array_0_3 of linearTile_3 @[Array.scala 21:78]
    array_0_3.clock <= clock
    array_0_3.reset <= reset
    inst array_1_0 of linearTile_4 @[Array.scala 21:78]
    array_1_0.clock <= clock
    array_1_0.reset <= reset
    inst array_1_1 of linearTile_5 @[Array.scala 21:78]
    array_1_1.clock <= clock
    array_1_1.reset <= reset
    inst array_1_2 of linearTile_6 @[Array.scala 21:78]
    array_1_2.clock <= clock
    array_1_2.reset <= reset
    inst array_1_3 of linearTile_7 @[Array.scala 21:78]
    array_1_3.clock <= clock
    array_1_3.reset <= reset
    inst array_2_0 of linearTile_8 @[Array.scala 21:78]
    array_2_0.clock <= clock
    array_2_0.reset <= reset
    inst array_2_1 of linearTile_9 @[Array.scala 21:78]
    array_2_1.clock <= clock
    array_2_1.reset <= reset
    inst array_2_2 of linearTile_10 @[Array.scala 21:78]
    array_2_2.clock <= clock
    array_2_2.reset <= reset
    inst array_2_3 of linearTile_11 @[Array.scala 21:78]
    array_2_3.clock <= clock
    array_2_3.reset <= reset
    inst array_3_0 of linearTile_12 @[Array.scala 21:78]
    array_3_0.clock <= clock
    array_3_0.reset <= reset
    inst array_3_1 of linearTile_13 @[Array.scala 21:78]
    array_3_1.clock <= clock
    array_3_1.reset <= reset
    inst array_3_2 of linearTile_14 @[Array.scala 21:78]
    array_3_2.clock <= clock
    array_3_2.reset <= reset
    inst array_3_3 of linearTile_15 @[Array.scala 21:78]
    array_3_3.clock <= clock
    array_3_3.reset <= reset
    inst A_convert_0 of toFloatingPointUnpacked @[Array.scala 24:84]
    A_convert_0.clock <= clock
    A_convert_0.reset <= reset
    inst A_convert_1 of toFloatingPointUnpacked_1 @[Array.scala 24:84]
    A_convert_1.clock <= clock
    A_convert_1.reset <= reset
    inst A_convert_2 of toFloatingPointUnpacked_2 @[Array.scala 24:84]
    A_convert_2.clock <= clock
    A_convert_2.reset <= reset
    inst A_convert_3 of toFloatingPointUnpacked_3 @[Array.scala 24:84]
    A_convert_3.clock <= clock
    A_convert_3.reset <= reset
    inst B_convert_0 of toFloatingPointUnpacked_4 @[Array.scala 25:84]
    B_convert_0.clock <= clock
    B_convert_0.reset <= reset
    inst B_convert_1 of toFloatingPointUnpacked_5 @[Array.scala 25:84]
    B_convert_1.clock <= clock
    B_convert_1.reset <= reset
    inst B_convert_2 of toFloatingPointUnpacked_6 @[Array.scala 25:84]
    B_convert_2.clock <= clock
    B_convert_2.reset <= reset
    inst B_convert_3 of toFloatingPointUnpacked_7 @[Array.scala 25:84]
    B_convert_3.clock <= clock
    B_convert_3.reset <= reset
    A_convert_0.io.in <= io.A_in[0] @[Array.scala 28:44]
    array_0_0.io.A_in.fraction <= A_convert_0.io.out.fraction @[Array.scala 29:45]
    array_0_0.io.A_in.exponent <= A_convert_0.io.out.exponent @[Array.scala 29:45]
    array_0_0.io.A_in.sign <= A_convert_0.io.out.sign @[Array.scala 29:45]
    array_0_0.io.A_in.nan <= A_convert_0.io.out.nan @[Array.scala 29:45]
    array_0_0.io.A_in.zero <= A_convert_0.io.out.zero @[Array.scala 29:45]
    array_0_0.io.C_in.number <= io.C_in[0].number @[Array.scala 30:45]
    array_0_0.io.C_in.nan <= io.C_in[0].nan @[Array.scala 30:45]
    array_0_0.io.C_in.zero <= io.C_in[0].zero @[Array.scala 30:45]
    array_0_0.io.prop_in <= io.prop_in[0] @[Array.scala 31:48]
    array_1_0.io.A_in.fraction <= array_0_0.io.A_out.fraction @[Array.scala 33:53]
    array_1_0.io.A_in.exponent <= array_0_0.io.A_out.exponent @[Array.scala 33:53]
    array_1_0.io.A_in.sign <= array_0_0.io.A_out.sign @[Array.scala 33:53]
    array_1_0.io.A_in.nan <= array_0_0.io.A_out.nan @[Array.scala 33:53]
    array_1_0.io.A_in.zero <= array_0_0.io.A_out.zero @[Array.scala 33:53]
    array_1_0.io.C_in.number <= array_0_0.io.C_out.number @[Array.scala 34:53]
    array_1_0.io.C_in.nan <= array_0_0.io.C_out.nan @[Array.scala 34:53]
    array_1_0.io.C_in.zero <= array_0_0.io.C_out.zero @[Array.scala 34:53]
    array_1_0.io.prop_in <= array_0_0.io.prop_out @[Array.scala 35:56]
    array_2_0.io.A_in.fraction <= array_1_0.io.A_out.fraction @[Array.scala 33:53]
    array_2_0.io.A_in.exponent <= array_1_0.io.A_out.exponent @[Array.scala 33:53]
    array_2_0.io.A_in.sign <= array_1_0.io.A_out.sign @[Array.scala 33:53]
    array_2_0.io.A_in.nan <= array_1_0.io.A_out.nan @[Array.scala 33:53]
    array_2_0.io.A_in.zero <= array_1_0.io.A_out.zero @[Array.scala 33:53]
    array_2_0.io.C_in.number <= array_1_0.io.C_out.number @[Array.scala 34:53]
    array_2_0.io.C_in.nan <= array_1_0.io.C_out.nan @[Array.scala 34:53]
    array_2_0.io.C_in.zero <= array_1_0.io.C_out.zero @[Array.scala 34:53]
    array_2_0.io.prop_in <= array_1_0.io.prop_out @[Array.scala 35:56]
    array_3_0.io.A_in.fraction <= array_2_0.io.A_out.fraction @[Array.scala 33:53]
    array_3_0.io.A_in.exponent <= array_2_0.io.A_out.exponent @[Array.scala 33:53]
    array_3_0.io.A_in.sign <= array_2_0.io.A_out.sign @[Array.scala 33:53]
    array_3_0.io.A_in.nan <= array_2_0.io.A_out.nan @[Array.scala 33:53]
    array_3_0.io.A_in.zero <= array_2_0.io.A_out.zero @[Array.scala 33:53]
    array_3_0.io.C_in.number <= array_2_0.io.C_out.number @[Array.scala 34:53]
    array_3_0.io.C_in.nan <= array_2_0.io.C_out.nan @[Array.scala 34:53]
    array_3_0.io.C_in.zero <= array_2_0.io.C_out.zero @[Array.scala 34:53]
    array_3_0.io.prop_in <= array_2_0.io.prop_out @[Array.scala 35:56]
    io.C_out[0].number <= array_3_0.io.C_out.number @[Array.scala 37:37]
    io.C_out[0].nan <= array_3_0.io.C_out.nan @[Array.scala 37:37]
    io.C_out[0].zero <= array_3_0.io.C_out.zero @[Array.scala 37:37]
    A_convert_1.io.in <= io.A_in[1] @[Array.scala 28:44]
    array_0_1.io.A_in.fraction <= A_convert_1.io.out.fraction @[Array.scala 29:45]
    array_0_1.io.A_in.exponent <= A_convert_1.io.out.exponent @[Array.scala 29:45]
    array_0_1.io.A_in.sign <= A_convert_1.io.out.sign @[Array.scala 29:45]
    array_0_1.io.A_in.nan <= A_convert_1.io.out.nan @[Array.scala 29:45]
    array_0_1.io.A_in.zero <= A_convert_1.io.out.zero @[Array.scala 29:45]
    array_0_1.io.C_in.number <= io.C_in[1].number @[Array.scala 30:45]
    array_0_1.io.C_in.nan <= io.C_in[1].nan @[Array.scala 30:45]
    array_0_1.io.C_in.zero <= io.C_in[1].zero @[Array.scala 30:45]
    array_0_1.io.prop_in <= io.prop_in[1] @[Array.scala 31:48]
    array_1_1.io.A_in.fraction <= array_0_1.io.A_out.fraction @[Array.scala 33:53]
    array_1_1.io.A_in.exponent <= array_0_1.io.A_out.exponent @[Array.scala 33:53]
    array_1_1.io.A_in.sign <= array_0_1.io.A_out.sign @[Array.scala 33:53]
    array_1_1.io.A_in.nan <= array_0_1.io.A_out.nan @[Array.scala 33:53]
    array_1_1.io.A_in.zero <= array_0_1.io.A_out.zero @[Array.scala 33:53]
    array_1_1.io.C_in.number <= array_0_1.io.C_out.number @[Array.scala 34:53]
    array_1_1.io.C_in.nan <= array_0_1.io.C_out.nan @[Array.scala 34:53]
    array_1_1.io.C_in.zero <= array_0_1.io.C_out.zero @[Array.scala 34:53]
    array_1_1.io.prop_in <= array_0_1.io.prop_out @[Array.scala 35:56]
    array_2_1.io.A_in.fraction <= array_1_1.io.A_out.fraction @[Array.scala 33:53]
    array_2_1.io.A_in.exponent <= array_1_1.io.A_out.exponent @[Array.scala 33:53]
    array_2_1.io.A_in.sign <= array_1_1.io.A_out.sign @[Array.scala 33:53]
    array_2_1.io.A_in.nan <= array_1_1.io.A_out.nan @[Array.scala 33:53]
    array_2_1.io.A_in.zero <= array_1_1.io.A_out.zero @[Array.scala 33:53]
    array_2_1.io.C_in.number <= array_1_1.io.C_out.number @[Array.scala 34:53]
    array_2_1.io.C_in.nan <= array_1_1.io.C_out.nan @[Array.scala 34:53]
    array_2_1.io.C_in.zero <= array_1_1.io.C_out.zero @[Array.scala 34:53]
    array_2_1.io.prop_in <= array_1_1.io.prop_out @[Array.scala 35:56]
    array_3_1.io.A_in.fraction <= array_2_1.io.A_out.fraction @[Array.scala 33:53]
    array_3_1.io.A_in.exponent <= array_2_1.io.A_out.exponent @[Array.scala 33:53]
    array_3_1.io.A_in.sign <= array_2_1.io.A_out.sign @[Array.scala 33:53]
    array_3_1.io.A_in.nan <= array_2_1.io.A_out.nan @[Array.scala 33:53]
    array_3_1.io.A_in.zero <= array_2_1.io.A_out.zero @[Array.scala 33:53]
    array_3_1.io.C_in.number <= array_2_1.io.C_out.number @[Array.scala 34:53]
    array_3_1.io.C_in.nan <= array_2_1.io.C_out.nan @[Array.scala 34:53]
    array_3_1.io.C_in.zero <= array_2_1.io.C_out.zero @[Array.scala 34:53]
    array_3_1.io.prop_in <= array_2_1.io.prop_out @[Array.scala 35:56]
    io.C_out[1].number <= array_3_1.io.C_out.number @[Array.scala 37:37]
    io.C_out[1].nan <= array_3_1.io.C_out.nan @[Array.scala 37:37]
    io.C_out[1].zero <= array_3_1.io.C_out.zero @[Array.scala 37:37]
    A_convert_2.io.in <= io.A_in[2] @[Array.scala 28:44]
    array_0_2.io.A_in.fraction <= A_convert_2.io.out.fraction @[Array.scala 29:45]
    array_0_2.io.A_in.exponent <= A_convert_2.io.out.exponent @[Array.scala 29:45]
    array_0_2.io.A_in.sign <= A_convert_2.io.out.sign @[Array.scala 29:45]
    array_0_2.io.A_in.nan <= A_convert_2.io.out.nan @[Array.scala 29:45]
    array_0_2.io.A_in.zero <= A_convert_2.io.out.zero @[Array.scala 29:45]
    array_0_2.io.C_in.number <= io.C_in[2].number @[Array.scala 30:45]
    array_0_2.io.C_in.nan <= io.C_in[2].nan @[Array.scala 30:45]
    array_0_2.io.C_in.zero <= io.C_in[2].zero @[Array.scala 30:45]
    array_0_2.io.prop_in <= io.prop_in[2] @[Array.scala 31:48]
    array_1_2.io.A_in.fraction <= array_0_2.io.A_out.fraction @[Array.scala 33:53]
    array_1_2.io.A_in.exponent <= array_0_2.io.A_out.exponent @[Array.scala 33:53]
    array_1_2.io.A_in.sign <= array_0_2.io.A_out.sign @[Array.scala 33:53]
    array_1_2.io.A_in.nan <= array_0_2.io.A_out.nan @[Array.scala 33:53]
    array_1_2.io.A_in.zero <= array_0_2.io.A_out.zero @[Array.scala 33:53]
    array_1_2.io.C_in.number <= array_0_2.io.C_out.number @[Array.scala 34:53]
    array_1_2.io.C_in.nan <= array_0_2.io.C_out.nan @[Array.scala 34:53]
    array_1_2.io.C_in.zero <= array_0_2.io.C_out.zero @[Array.scala 34:53]
    array_1_2.io.prop_in <= array_0_2.io.prop_out @[Array.scala 35:56]
    array_2_2.io.A_in.fraction <= array_1_2.io.A_out.fraction @[Array.scala 33:53]
    array_2_2.io.A_in.exponent <= array_1_2.io.A_out.exponent @[Array.scala 33:53]
    array_2_2.io.A_in.sign <= array_1_2.io.A_out.sign @[Array.scala 33:53]
    array_2_2.io.A_in.nan <= array_1_2.io.A_out.nan @[Array.scala 33:53]
    array_2_2.io.A_in.zero <= array_1_2.io.A_out.zero @[Array.scala 33:53]
    array_2_2.io.C_in.number <= array_1_2.io.C_out.number @[Array.scala 34:53]
    array_2_2.io.C_in.nan <= array_1_2.io.C_out.nan @[Array.scala 34:53]
    array_2_2.io.C_in.zero <= array_1_2.io.C_out.zero @[Array.scala 34:53]
    array_2_2.io.prop_in <= array_1_2.io.prop_out @[Array.scala 35:56]
    array_3_2.io.A_in.fraction <= array_2_2.io.A_out.fraction @[Array.scala 33:53]
    array_3_2.io.A_in.exponent <= array_2_2.io.A_out.exponent @[Array.scala 33:53]
    array_3_2.io.A_in.sign <= array_2_2.io.A_out.sign @[Array.scala 33:53]
    array_3_2.io.A_in.nan <= array_2_2.io.A_out.nan @[Array.scala 33:53]
    array_3_2.io.A_in.zero <= array_2_2.io.A_out.zero @[Array.scala 33:53]
    array_3_2.io.C_in.number <= array_2_2.io.C_out.number @[Array.scala 34:53]
    array_3_2.io.C_in.nan <= array_2_2.io.C_out.nan @[Array.scala 34:53]
    array_3_2.io.C_in.zero <= array_2_2.io.C_out.zero @[Array.scala 34:53]
    array_3_2.io.prop_in <= array_2_2.io.prop_out @[Array.scala 35:56]
    io.C_out[2].number <= array_3_2.io.C_out.number @[Array.scala 37:37]
    io.C_out[2].nan <= array_3_2.io.C_out.nan @[Array.scala 37:37]
    io.C_out[2].zero <= array_3_2.io.C_out.zero @[Array.scala 37:37]
    A_convert_3.io.in <= io.A_in[3] @[Array.scala 28:44]
    array_0_3.io.A_in.fraction <= A_convert_3.io.out.fraction @[Array.scala 29:45]
    array_0_3.io.A_in.exponent <= A_convert_3.io.out.exponent @[Array.scala 29:45]
    array_0_3.io.A_in.sign <= A_convert_3.io.out.sign @[Array.scala 29:45]
    array_0_3.io.A_in.nan <= A_convert_3.io.out.nan @[Array.scala 29:45]
    array_0_3.io.A_in.zero <= A_convert_3.io.out.zero @[Array.scala 29:45]
    array_0_3.io.C_in.number <= io.C_in[3].number @[Array.scala 30:45]
    array_0_3.io.C_in.nan <= io.C_in[3].nan @[Array.scala 30:45]
    array_0_3.io.C_in.zero <= io.C_in[3].zero @[Array.scala 30:45]
    array_0_3.io.prop_in <= io.prop_in[3] @[Array.scala 31:48]
    array_1_3.io.A_in.fraction <= array_0_3.io.A_out.fraction @[Array.scala 33:53]
    array_1_3.io.A_in.exponent <= array_0_3.io.A_out.exponent @[Array.scala 33:53]
    array_1_3.io.A_in.sign <= array_0_3.io.A_out.sign @[Array.scala 33:53]
    array_1_3.io.A_in.nan <= array_0_3.io.A_out.nan @[Array.scala 33:53]
    array_1_3.io.A_in.zero <= array_0_3.io.A_out.zero @[Array.scala 33:53]
    array_1_3.io.C_in.number <= array_0_3.io.C_out.number @[Array.scala 34:53]
    array_1_3.io.C_in.nan <= array_0_3.io.C_out.nan @[Array.scala 34:53]
    array_1_3.io.C_in.zero <= array_0_3.io.C_out.zero @[Array.scala 34:53]
    array_1_3.io.prop_in <= array_0_3.io.prop_out @[Array.scala 35:56]
    array_2_3.io.A_in.fraction <= array_1_3.io.A_out.fraction @[Array.scala 33:53]
    array_2_3.io.A_in.exponent <= array_1_3.io.A_out.exponent @[Array.scala 33:53]
    array_2_3.io.A_in.sign <= array_1_3.io.A_out.sign @[Array.scala 33:53]
    array_2_3.io.A_in.nan <= array_1_3.io.A_out.nan @[Array.scala 33:53]
    array_2_3.io.A_in.zero <= array_1_3.io.A_out.zero @[Array.scala 33:53]
    array_2_3.io.C_in.number <= array_1_3.io.C_out.number @[Array.scala 34:53]
    array_2_3.io.C_in.nan <= array_1_3.io.C_out.nan @[Array.scala 34:53]
    array_2_3.io.C_in.zero <= array_1_3.io.C_out.zero @[Array.scala 34:53]
    array_2_3.io.prop_in <= array_1_3.io.prop_out @[Array.scala 35:56]
    array_3_3.io.A_in.fraction <= array_2_3.io.A_out.fraction @[Array.scala 33:53]
    array_3_3.io.A_in.exponent <= array_2_3.io.A_out.exponent @[Array.scala 33:53]
    array_3_3.io.A_in.sign <= array_2_3.io.A_out.sign @[Array.scala 33:53]
    array_3_3.io.A_in.nan <= array_2_3.io.A_out.nan @[Array.scala 33:53]
    array_3_3.io.A_in.zero <= array_2_3.io.A_out.zero @[Array.scala 33:53]
    array_3_3.io.C_in.number <= array_2_3.io.C_out.number @[Array.scala 34:53]
    array_3_3.io.C_in.nan <= array_2_3.io.C_out.nan @[Array.scala 34:53]
    array_3_3.io.C_in.zero <= array_2_3.io.C_out.zero @[Array.scala 34:53]
    array_3_3.io.prop_in <= array_2_3.io.prop_out @[Array.scala 35:56]
    io.C_out[3].number <= array_3_3.io.C_out.number @[Array.scala 37:37]
    io.C_out[3].nan <= array_3_3.io.C_out.nan @[Array.scala 37:37]
    io.C_out[3].zero <= array_3_3.io.C_out.zero @[Array.scala 37:37]
    B_convert_0.io.in <= io.B_in[0] @[Array.scala 41:44]
    array_0_0.io.B_in.fraction <= B_convert_0.io.out.fraction @[Array.scala 42:45]
    array_0_0.io.B_in.exponent <= B_convert_0.io.out.exponent @[Array.scala 42:45]
    array_0_0.io.B_in.sign <= B_convert_0.io.out.sign @[Array.scala 42:45]
    array_0_0.io.B_in.nan <= B_convert_0.io.out.nan @[Array.scala 42:45]
    array_0_0.io.B_in.zero <= B_convert_0.io.out.zero @[Array.scala 42:45]
    array_0_1.io.B_in.fraction <= array_0_0.io.B_out.fraction @[Array.scala 44:53]
    array_0_1.io.B_in.exponent <= array_0_0.io.B_out.exponent @[Array.scala 44:53]
    array_0_1.io.B_in.sign <= array_0_0.io.B_out.sign @[Array.scala 44:53]
    array_0_1.io.B_in.nan <= array_0_0.io.B_out.nan @[Array.scala 44:53]
    array_0_1.io.B_in.zero <= array_0_0.io.B_out.zero @[Array.scala 44:53]
    array_0_2.io.B_in.fraction <= array_0_1.io.B_out.fraction @[Array.scala 44:53]
    array_0_2.io.B_in.exponent <= array_0_1.io.B_out.exponent @[Array.scala 44:53]
    array_0_2.io.B_in.sign <= array_0_1.io.B_out.sign @[Array.scala 44:53]
    array_0_2.io.B_in.nan <= array_0_1.io.B_out.nan @[Array.scala 44:53]
    array_0_2.io.B_in.zero <= array_0_1.io.B_out.zero @[Array.scala 44:53]
    array_0_3.io.B_in.fraction <= array_0_2.io.B_out.fraction @[Array.scala 44:53]
    array_0_3.io.B_in.exponent <= array_0_2.io.B_out.exponent @[Array.scala 44:53]
    array_0_3.io.B_in.sign <= array_0_2.io.B_out.sign @[Array.scala 44:53]
    array_0_3.io.B_in.nan <= array_0_2.io.B_out.nan @[Array.scala 44:53]
    array_0_3.io.B_in.zero <= array_0_2.io.B_out.zero @[Array.scala 44:53]
    B_convert_1.io.in <= io.B_in[1] @[Array.scala 41:44]
    array_1_0.io.B_in.fraction <= B_convert_1.io.out.fraction @[Array.scala 42:45]
    array_1_0.io.B_in.exponent <= B_convert_1.io.out.exponent @[Array.scala 42:45]
    array_1_0.io.B_in.sign <= B_convert_1.io.out.sign @[Array.scala 42:45]
    array_1_0.io.B_in.nan <= B_convert_1.io.out.nan @[Array.scala 42:45]
    array_1_0.io.B_in.zero <= B_convert_1.io.out.zero @[Array.scala 42:45]
    array_1_1.io.B_in.fraction <= array_1_0.io.B_out.fraction @[Array.scala 44:53]
    array_1_1.io.B_in.exponent <= array_1_0.io.B_out.exponent @[Array.scala 44:53]
    array_1_1.io.B_in.sign <= array_1_0.io.B_out.sign @[Array.scala 44:53]
    array_1_1.io.B_in.nan <= array_1_0.io.B_out.nan @[Array.scala 44:53]
    array_1_1.io.B_in.zero <= array_1_0.io.B_out.zero @[Array.scala 44:53]
    array_1_2.io.B_in.fraction <= array_1_1.io.B_out.fraction @[Array.scala 44:53]
    array_1_2.io.B_in.exponent <= array_1_1.io.B_out.exponent @[Array.scala 44:53]
    array_1_2.io.B_in.sign <= array_1_1.io.B_out.sign @[Array.scala 44:53]
    array_1_2.io.B_in.nan <= array_1_1.io.B_out.nan @[Array.scala 44:53]
    array_1_2.io.B_in.zero <= array_1_1.io.B_out.zero @[Array.scala 44:53]
    array_1_3.io.B_in.fraction <= array_1_2.io.B_out.fraction @[Array.scala 44:53]
    array_1_3.io.B_in.exponent <= array_1_2.io.B_out.exponent @[Array.scala 44:53]
    array_1_3.io.B_in.sign <= array_1_2.io.B_out.sign @[Array.scala 44:53]
    array_1_3.io.B_in.nan <= array_1_2.io.B_out.nan @[Array.scala 44:53]
    array_1_3.io.B_in.zero <= array_1_2.io.B_out.zero @[Array.scala 44:53]
    B_convert_2.io.in <= io.B_in[2] @[Array.scala 41:44]
    array_2_0.io.B_in.fraction <= B_convert_2.io.out.fraction @[Array.scala 42:45]
    array_2_0.io.B_in.exponent <= B_convert_2.io.out.exponent @[Array.scala 42:45]
    array_2_0.io.B_in.sign <= B_convert_2.io.out.sign @[Array.scala 42:45]
    array_2_0.io.B_in.nan <= B_convert_2.io.out.nan @[Array.scala 42:45]
    array_2_0.io.B_in.zero <= B_convert_2.io.out.zero @[Array.scala 42:45]
    array_2_1.io.B_in.fraction <= array_2_0.io.B_out.fraction @[Array.scala 44:53]
    array_2_1.io.B_in.exponent <= array_2_0.io.B_out.exponent @[Array.scala 44:53]
    array_2_1.io.B_in.sign <= array_2_0.io.B_out.sign @[Array.scala 44:53]
    array_2_1.io.B_in.nan <= array_2_0.io.B_out.nan @[Array.scala 44:53]
    array_2_1.io.B_in.zero <= array_2_0.io.B_out.zero @[Array.scala 44:53]
    array_2_2.io.B_in.fraction <= array_2_1.io.B_out.fraction @[Array.scala 44:53]
    array_2_2.io.B_in.exponent <= array_2_1.io.B_out.exponent @[Array.scala 44:53]
    array_2_2.io.B_in.sign <= array_2_1.io.B_out.sign @[Array.scala 44:53]
    array_2_2.io.B_in.nan <= array_2_1.io.B_out.nan @[Array.scala 44:53]
    array_2_2.io.B_in.zero <= array_2_1.io.B_out.zero @[Array.scala 44:53]
    array_2_3.io.B_in.fraction <= array_2_2.io.B_out.fraction @[Array.scala 44:53]
    array_2_3.io.B_in.exponent <= array_2_2.io.B_out.exponent @[Array.scala 44:53]
    array_2_3.io.B_in.sign <= array_2_2.io.B_out.sign @[Array.scala 44:53]
    array_2_3.io.B_in.nan <= array_2_2.io.B_out.nan @[Array.scala 44:53]
    array_2_3.io.B_in.zero <= array_2_2.io.B_out.zero @[Array.scala 44:53]
    B_convert_3.io.in <= io.B_in[3] @[Array.scala 41:44]
    array_3_0.io.B_in.fraction <= B_convert_3.io.out.fraction @[Array.scala 42:45]
    array_3_0.io.B_in.exponent <= B_convert_3.io.out.exponent @[Array.scala 42:45]
    array_3_0.io.B_in.sign <= B_convert_3.io.out.sign @[Array.scala 42:45]
    array_3_0.io.B_in.nan <= B_convert_3.io.out.nan @[Array.scala 42:45]
    array_3_0.io.B_in.zero <= B_convert_3.io.out.zero @[Array.scala 42:45]
    array_3_1.io.B_in.fraction <= array_3_0.io.B_out.fraction @[Array.scala 44:53]
    array_3_1.io.B_in.exponent <= array_3_0.io.B_out.exponent @[Array.scala 44:53]
    array_3_1.io.B_in.sign <= array_3_0.io.B_out.sign @[Array.scala 44:53]
    array_3_1.io.B_in.nan <= array_3_0.io.B_out.nan @[Array.scala 44:53]
    array_3_1.io.B_in.zero <= array_3_0.io.B_out.zero @[Array.scala 44:53]
    array_3_2.io.B_in.fraction <= array_3_1.io.B_out.fraction @[Array.scala 44:53]
    array_3_2.io.B_in.exponent <= array_3_1.io.B_out.exponent @[Array.scala 44:53]
    array_3_2.io.B_in.sign <= array_3_1.io.B_out.sign @[Array.scala 44:53]
    array_3_2.io.B_in.nan <= array_3_1.io.B_out.nan @[Array.scala 44:53]
    array_3_2.io.B_in.zero <= array_3_1.io.B_out.zero @[Array.scala 44:53]
    array_3_3.io.B_in.fraction <= array_3_2.io.B_out.fraction @[Array.scala 44:53]
    array_3_3.io.B_in.exponent <= array_3_2.io.B_out.exponent @[Array.scala 44:53]
    array_3_3.io.B_in.sign <= array_3_2.io.B_out.sign @[Array.scala 44:53]
    array_3_3.io.B_in.nan <= array_3_2.io.B_out.nan @[Array.scala 44:53]
    array_3_3.io.B_in.zero <= array_3_2.io.B_out.zero @[Array.scala 44:53]
    
